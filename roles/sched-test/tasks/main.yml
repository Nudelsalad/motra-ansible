---
- name: Define scxctl binary path
  set_fact:
    scxctl_bin_path: "/home/{{ motra_user }}/.cargo/bin/scxctl"
  tags: [scheduler, sched_test]

- name: Ensure SCENARIO and SCHEDULER are set in compose .env
  become: true
  become_user: "{{ motra_user }}"
  lineinfile:
    path: "{{ sched_test_workdir }}/.env"
    regexp: "^{{ item.key }}="
    line: "{{ item.key }}={{ item.value }}"
    create: yes
  loop:
    - { key: "SCHEDULER", value: "{{ sched_test_scheduler }}" }
  tags: [env, sched_test]

- name: Manage scheduler switching
  block:
    - name: Switch scheduler - stop sched_ext (cfs)
      become: true
      command: "{{ scxctl_bin_path }} stop"
      register: scxctl_stop
      changed_when: "scxctl_stop.rc == 0"
      failed_when: false
      when: sched_test_scheduler | lower == 'cfs'

    - name: Derive scheduler name for scxctl (strip scx_ prefix)
      set_fact:
        sched_test_loader_name: "{{ (sched_test_scheduler | lower) | regex_replace('^scx_', '') }}"
      when: sched_test_scheduler | lower != 'cfs'

    - name: Switch scheduler via scxctl (try switch first)
      become: true
      command: "{{ scxctl_bin_path }} switch -s {{ sched_test_loader_name | default(sched_test_scheduler | lower) }}"
      register: scx_switch_result
      changed_when: "scx_switch_result.rc == 0"
      failed_when: false
      when: sched_test_scheduler | lower != 'cfs'

    - name: Start scheduler via scxctl when switch failed
      become: true
      command: "{{ scxctl_bin_path }} start -s {{ sched_test_loader_name | default(sched_test_scheduler | lower) }}"
      register: scx_start_result
      changed_when: "scx_start_result.rc == 0"
      failed_when: false
      when:
        - sched_test_scheduler | lower != 'cfs'
        - scx_switch_result.rc | default(0) != 0 # Simplified

    - name: Decide if fallback to direct scheduler binary is needed
      set_fact:
        sched_test_fallback_needed: true
      when:
        - sched_test_scheduler | lower != 'cfs'
        - scx_start_result.rc | default(0) != 0 # Simplified

    - name: Compute direct scheduler binary path
      set_fact:
        sched_test_scheduler_bin: "/home/{{ motra_user }}/.cargo/bin/scx_{{ sched_test_loader_name | default(sched_test_scheduler | lower) }}"
      when: sched_test_fallback_needed | default(false)

    - name: Check if direct scheduler binary exists
      stat:
        path: "{{ sched_test_scheduler_bin }}"
      register: sched_bin_stat
      when: sched_test_fallback_needed | default(false)

    - name: Start scheduler directly as background process (fallback)
      become: true
      ansible.builtin.shell: |
        set -euo pipefail
        nohup "{{ sched_test_scheduler_bin }}" >"/tmp/{{ sched_test_loader_name | default(sched_test_scheduler | lower) }}.log" 2>&1 & echo $! > "/tmp/{{ sched_test_loader_name | default(sched_test_scheduler | lower) }}.pid"
      args:
        executable: /bin/bash
      when:
        - sched_test_fallback_needed | default(false)
        - sched_bin_stat.stat.exists | default(false)
      register: sched_fallback_start
      changed_when: true

    - name: Warn when no direct scheduler binary found
      meta: noop
      when:
        - sched_test_fallback_needed | default(false)
        - not (sched_bin_stat.stat.exists | default(false))

    - name: Stabilize after scheduler switch
      ansible.builtin.wait_for:
        timeout: 5

  when: sched_test_switch_scheduler
  tags: [scheduler, sched_test]
# -----------------------------------------------------------------
# END OF SCHEDULER BLOCK
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# BLOCK FOR TEST RUN WITH GUARANTEED CLEANUP
# -----------------------------------------------------------------
- name: Run test scenario with guaranteed cleanup
  block:
    - name: Bring up monitoring profile on plc stack
      become: true
      become_user: "{{ motra_user }}"
      ansible.builtin.shell: |
        set -euo pipefail
        docker compose -f plc.yml --profile monitoring up -d
      args:
        chdir: "{{ sched_test_workdir }}"
        executable: /bin/bash
      tags: [compose, server, monitoring, sched_test]

    - name: Wait for services to settle
      ansible.builtin.wait_for:
        timeout: "{{ sched_test_wait_after_up }}"
      tags: [wait, sched_test]

    - name: Start attacker (server) when enabled
      become: true
      become_user: "{{ motra_user }}"
      ansible.builtin.shell: |
        set -euo pipefail
        docker compose -f attacker.yml --profile attack up -d
      args:
        chdir: "{{ sched_test_workdir }}"
        executable: /bin/bash
      when:
        - sched_test_attack | bool
      tags: [attack, sched_test]

    - name: Optional pre-attack wait
      ansible.builtin.wait_for:
        timeout: "{{ sched_test_wait_before_attack }}"
      when: sched_test_attack | bool
      tags: [wait, sched_test]

    - name: Run attack for duration (server)
      ansible.builtin.wait_for:
        timeout: "{{ sched_test_attack_duration }}"
      when:
        - sched_test_attack | bool
      tags: [attack, sched_test]

  always:
    - name: Stop attacker container (cleanup)
      become: true
      become_user: "{{ motra_user }}"
      ansible.builtin.docker_container:
        name: cve-attacker
        state: absent
        force_kill: yes
      args:
        chdir: "{{ sched_test_workdir }}"
      when:
        - sched_test_attack | bool
        - sched_test_stop_attack_after | bool
      tags: [attack, cleanup, sched_test]
